#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/*
  WAR Estruturado - Miss√µes Estrat√©gicas (Desafio Final)
  - Usa structs, ponteiros, aloca√ß√£o din√¢mica e modulariza√ß√£o.
  - Autor: (Seu Nome)
  - Data: (coloque a data do commit)
*/

/* Estrutura que representa um territ√≥rio */
typedef struct {
    char nome[30];
    char cor[10];
    int tropas;
} Territorio;

/* ---------- Prot√≥tipos das fun√ß√µes ---------- */
Territorio* criarMapa(int tamanho);
void cadastrarTerritorios(Territorio *mapa, int qtd);
void exibirMapa(Territorio *mapa, int qtd);
void atacar(Territorio *atacante, Territorio *defensor);
void liberarMapa(Territorio *mapa);

void atribuirMissao(char **destino, char *missoes[], int totalMissoes);
int verificarMissao(char *missao, Territorio *mapa, int tamanho, char *corJogador);
void exibirMissao(const char *missao);

/* ---------- Implementa√ß√µes ---------- */

/* Aloca dinamicamente o vetor de territ√≥rios */
Territorio* criarMapa(int tamanho) {
    Territorio *mapa = (Territorio *)calloc(tamanho, sizeof(Territorio));
    if (mapa == NULL) {
        printf("Erro: falha ao alocar mem√≥ria para o mapa.\n");
        exit(1);
    }
    return mapa;
}

/* Fun√ß√£o para cadastrar territ√≥rios (usa ponteiros) */
void cadastrarTerritorios(Territorio *mapa, int qtd) {
    for (int i = 0; i < qtd; i++) {
        printf("\n=== Cadastro do territ√≥rio %d/%d ===\n", i + 1, qtd);
        printf("Nome: ");
        scanf(" %[^\n]", mapa[i].nome); // permite espa√ßos
        printf("Cor do ex√©rcito (ex: vermelho, azul): ");
        scanf(" %[^\n]", mapa[i].cor);
        printf("Quantidade de tropas: ");
        scanf("%d", &mapa[i].tropas);
    }
}

/* Exibe o estado atual do mapa */
void exibirMapa(Territorio *mapa, int qtd) {
    printf("\n===== MAPA ATUAL (%d territ√≥rios) =====\n", qtd);
    for (int i = 0; i < qtd; i++) {
        printf("%2d) Nome: %-20s | Cor: %-8s | Tropas: %2d\n",
               i + 1, mapa[i].nome, mapa[i].cor, mapa[i].tropas);
    }
    printf("======================================\n");
}

/* Simula um ataque entre dois territ√≥rios apontados por ponteiros */
void atacar(Territorio *atacante, Territorio *defensor) {
    if (strcmp(atacante->cor, defensor->cor) == 0) {
        printf("\n‚ùå Ataque inv√°lido: mesmo ex√©rcito (mesma cor).\n");
        return;
    }
    if (atacante->tropas <= 0) {
        printf("\n‚ö†Ô∏è  Ataque imposs√≠vel: atacante n√£o tem tropas.\n");
        return;
    }

    int dadoA = (rand() % 6) + 1;
    int dadoD = (rand() % 6) + 1;

    printf("\nüé≤ Rolagem: %s (Atacante) -> %d | %s (Defensor) -> %d\n",
           atacante->nome, dadoA, defensor->nome, dadoD);

    if (dadoA > dadoD) {
        printf("üî• %s venceu e conquista %s!\n", atacante->nome, defensor->nome);
        // Transfere controle: defensor assume cor do atacante
        strcpy(defensor->cor, atacante->cor);

        // Atualiza tropas: defensor recebe metade das tropas do atacante (inteiro)
        int transfer = atacante->tropas / 2;
        if (transfer <= 0) transfer = 1; // garante alguma tropa m√≠nima
        defensor->tropas = transfer;

        // Opcional: atacante fica com as tropas restantes (aqui deixamos inalterado,
        // mas poder√≠amos reduzir). Vamos reduzir para refletir perdas:
        atacante->tropas -= transfer;
        if (atacante->tropas < 0) atacante->tropas = 0;

        printf("üìå Resultado: %s agora tem %d tropas e pertence a %s.\n",
               defensor->nome, defensor->tropas, defensor->cor);
    } else {
        printf("üõ°Ô∏è  %s resistiu ao ataque!\n", defensor->nome);
        // Atacante perde uma tropa por falha
        atacante->tropas--;
        if (atacante->tropas < 0) atacante->tropas = 0;
        printf("üìâ %s perdeu 1 tropa (agora %d tropas).\n",
               atacante->nome, atacante->tropas);
    }
}

/* Libera o mapa (mem√≥ria alocada por calloc/malloc) */
void liberarMapa(Territorio *mapa) {
    free(mapa);
}

/* Atribui aleatoriamente uma miss√£o ao jogador copiando para destino (alocado externamente) */
/* destino: endere√ßo que receber√° o ponteiro alocado; missoes[]: vetor de strings; totalMissoes: quantidade */
void atribuirMissao(char **destino, char *missoes[], int totalMissoes) {
    int idx = rand() % totalMissoes;
    size_t len = strlen(missoes[idx]);
    *destino = (char *)malloc(len + 1);
    if (*destino == NULL) {
        printf("Erro ao alocar mem√≥ria para a miss√£o.\n");
        exit(1);
    }
    strcpy(*destino, missoes[idx]);
}

/* Exibe a miss√£o ‚Äî passagem por valor (const char *) */
void exibirMissao(const char *missao) {
    printf("\n--- MISS√ÉO A VOC√ä ---\n%s\n----------------------\n", missao);
}

/*
  Verifica se uma miss√£o foi cumprida.
  Nota: estendemos a assinatura para receber tamb√©m a cor do jogador (corJogador),
  porque a maioria das miss√µes dependem de "quais territ√≥rios pertencem ao jogador".
  Retorna 1 se cumprida, 0 caso contr√°rio.
*/
int verificarMissao(char *missao, Territorio *mapa, int tamanho, char *corJogador) {
    /* Miss√µes implementadas (padr√£o) - l√≥gica simples */
    if (strstr(missao, "3 territ√≥rios seguidos") != NULL) {
        /* verificar se existem 3 territ√≥rios consecutivos com cor == corJogador */
        int consec = 0;
        for (int i = 0; i < tamanho; i++) {
            if (strcmp(mapa[i].cor, corJogador) == 0) {
                consec++;
                if (consec >= 3) return 1;
            } else {
                consec = 0;
            }
        }
        return 0;
    } else if (strstr(missao, "5 territ√≥rios no total") != NULL) {
        /* contar territ√≥rios do jogador */
        int cont = 0;
        for (int i = 0; i < tamanho; i++)
            if (strcmp(mapa[i].cor, corJogador) == 0) cont++;
        return (cont >= 5) ? 1 : 0;
    } else if (strstr(missao, "10 tropas") != NULL) {
        /* verificar se o jogador tem ao menos 10 tropas em um √∫nico territ√≥rio */
        for (int i = 0; i < tamanho; i++)
            if ((strcmp(mapa[i].cor, corJogador) == 0) && (mapa[i].tropas >= 10))
                return 1;
        return 0;
    } else if (strstr(missao, "Eliminar todas as tropas inimigas") != NULL ||
               strstr(missao, "Eliminar todas as tropas inimigas") != NULL) {
        /* verificar se n√£o existe territ√≥rio com tropas de outra cor */
        for (int i = 0; i < tamanho; i++) {
            if (strcmp(mapa[i].cor, corJogador) != 0 && mapa[i].tropas > 0)
                return 0;
        }
        return 1;
    } else if (strstr(missao, "50% ou mais dos territ√≥rios") != NULL) {
        int cont = 0;
        for (int i = 0; i < tamanho; i++)
            if (strcmp(mapa[i].cor, corJogador) == 0) cont++;
        return (cont * 100 >= 50 * tamanho) ? 1 : 0;
    }

    /* Miss√£o desconhecida -> n√£o cumprida por padr√£o */
    return 0;
}

/* ---------- Fun√ß√£o main: orquestra o jogo ---------- */
int main() {
    srand((unsigned int)time(NULL));

    int numTerritorios;
    printf("=== WAR Estruturado (Miss√µes Estrat√©gicas) ===\n");
    printf("Quantidade de territ√≥rios a cadastrar: ");
    scanf("%d", &numTerritorios);
    if (numTerritorios <= 0) {
        printf("Quantidade inv√°lida.\n");
        return 1;
    }

    Territorio *mapa = criarMapa(numTerritorios);
    cadastrarTerritorios(mapa, numTerritorios);
    exibirMapa(mapa, numTerritorios);

    /* Defini√ß√£o de miss√µes (vetor de strings) */
    char *missoes[] = {
        "Conquistar 3 territ√≥rios seguidos",
        "Conquistar 5 territ√≥rios no total",
        "Ter ao menos 10 tropas em um territ√≥rio",
        "Eliminar todas as tropas inimigas",
        "Controlar 50% ou mais dos territ√≥rios"
    };
    int totalMissoes = sizeof(missoes) / sizeof(missoes[0]);

    /* N√∫mero de jogadores (simples: 2 jogadores) */
    int numJogadores = 2;
    printf("\nN√∫mero de jogadores definido como %d (dois jogadores).\n", numJogadores);

    /* Array de cores dos jogadores: pedimos que*
